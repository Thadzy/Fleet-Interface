import { useState, useCallback, useEffect } from 'react';
import { supabase } from '../lib/supabaseClient';

// --- TYPE DEFINITIONS ---

/**
 * Clean Task object used by the Frontend UI.
 * Flattens the nested database structure (joins) into simple strings.
 */
export interface Task {
  id: number;
  pickup_name: string;
  delivery_name: string;
  status: string;
  priority: number;
  queued_at: string; 
}

/**
 * Represents a valid drop-off/pickup point in the warehouse.
 * Mapped from 'wh_cells' and 'wh_nodes'.
 */
export interface AvailableLocation {
  cell_id: number;
  node_name: string;
  level: number | null;
}

/**
 * Internal Interface for the raw Supabase response.
 * Describes the nested structure returned by the join query.
 */
interface RawTaskDB {
  id: number;
  status: string;
  priority: number;
  queued_at: string;
  pickup: {
    node: { name: string } | null;
  } | null;
  delivery: {
    node: { name: string } | null;
  } | null;
}

// --- HOOK ---

/**
 * HOOK: useTasks
 * * Manages the fetching, creation, and deletion of Transport Tasks.
 * * Transforms complex Relational Data (Joins) into simple UI Data.
 */
export const useTasks = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [locations, setLocations] = useState<AvailableLocation[]>([]);
  const [loading, setLoading] = useState(false);

  // =========================================================
  // 1. FETCH TASKS (READ)
  // =========================================================
  const fetchTasks = useCallback(async () => {
    setLoading(true);
    try {
      // Query with Nested Joins: pd_pairs -> wh_cells -> wh_nodes
      // "pickup:pickup_cell_id" is an alias for the joined relationship
      const { data, error } = await supabase
        .from('pd_pairs')
        .select(`
          id,
          status,
          priority,
          queued_at, 
          pickup:pickup_cell_id (
            node:node_id (name)
          ),
          delivery:delivery_cell_id (
            node:node_id (name)
          )
        `)
        .order('queued_at', { ascending: false }); // Newest first

      if (error) throw error;

      // Transform Raw DB Data -> Clean UI Data
      // We cast 'data' to 'unknown' then 'RawTaskDB[]' to satisfy TypeScript 
      // because Supabase types for deep joins are often difficult to infer automatically.
      const formattedTasks: Task[] = (data as unknown as RawTaskDB[]).map((t) => ({
        id: t.id,
        pickup_name: t.pickup?.node?.name || 'Unknown Node',
        delivery_name: t.delivery?.node?.name || 'Unknown Node',
        status: t.status,
        priority: t.priority,
        queued_at: t.queued_at,
      }));

      setTasks(formattedTasks);
    } catch (err) {
      console.error('Error fetching tasks:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // =========================================================
  // 2. FETCH LOCATIONS (READ)
  // =========================================================
  const fetchLocations = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from('wh_cells')
        .select(`
          id,
          level:level_id (level),
          node:node_id (name)
        `);

      if (error) throw error;

      // Transform into a simple list for Dropdowns
      // Explicitly checking for nulls to avoid UI crashes
      const validLocs: AvailableLocation[] = (data as any[]).map((d) => ({
        cell_id: d.id,
        node_name: d.node?.name || `Cell #${d.id}`,
        level: d.level?.level || 1,
      }));
      
      setLocations(validLocs);
    } catch (err) {
      console.error('Error fetching locations:', err);
    }
  }, []);

  // =========================================================
  // 3. ADD TASK (CREATE)
  // =========================================================
  const addTask = async (pickupCellId: number, deliveryCellId: number) => {
    // Note: 'queued_at' is auto-generated by Postgres (DEFAULT now())
    const { error } = await supabase.from('pd_pairs').insert({
      pickup_cell_id: pickupCellId,
      delivery_cell_id: deliveryCellId,
      status: 'queuing',
      priority: 1, // Default priority
    });
    
    if (error) {
      console.error('Insert Failed:', error);
      alert(`Failed to add task: ${error.message}`);
      return false;
    }
    
    await fetchTasks(); // Refresh list immediately
    return true;
  };

  // =========================================================
  // 4. DELETE TASK (DELETE)
  // =========================================================
  const deleteTask = async (id: number) => {
    const { error } = await supabase.from('pd_pairs').delete().eq('id', id);
    
    if (error) {
        alert(`Failed to delete: ${error.message}`);
    } else {
        await fetchTasks();
    }
  };

  // Load initial data on mount
  useEffect(() => {
    fetchTasks();
    fetchLocations();
  }, [fetchTasks, fetchLocations]);

  return { tasks, locations, addTask, deleteTask, loading, refresh: fetchTasks };
};