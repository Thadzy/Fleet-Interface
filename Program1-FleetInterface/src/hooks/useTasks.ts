import { useState, useCallback, useEffect } from 'react';
import { supabase } from '../lib/supabaseClient';

// --- TYPE DEFINITIONS ---

/**
 * Clean Task object used by the Frontend UI.
 * Flattens the nested database structure (joins) into simple strings.
 */
export interface Task {
  id: number;
  pickup_cell_id: number;
  delivery_cell_id: number;
  pickup_name: string;
  delivery_name: string;
  status: string;
  priority: number;
  queued_at: string;
}

/**
 * Represents a valid drop-off/pickup point in the warehouse.
 * Mapped from 'wh_cells' and 'wh_nodes'.
 */
export interface AvailableLocation {
  cell_id: number;
  node_name: string;
  level: number | null;
}

/**
 * Internal Interface for the raw Supabase response.
 * Describes the nested structure returned by the join query.
 */
interface RawTaskDB {
  id: number;
  pickup_cell_id: number;
  delivery_cell_id: number;
  status: string;
  priority: number;
  created_at?: string;  // New schema uses created_at
  queued_at?: string;    // Old schema used queued_at (for backward compatibility)
  pickup: {
    node: { name: string } | null;
  } | null;
  delivery: {
    node: { name: string } | null;
  } | null;
}

// --- HOOK ---

/**
 * HOOK: useTasks
 * * Manages the fetching, creation, and deletion of Transport Tasks.
 * * Transforms complex Relational Data (Joins) into simple UI Data.
 */
export const useTasks = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [locations, setLocations] = useState<AvailableLocation[]>([]);
  const [loading, setLoading] = useState(false);

  // =========================================================
  // 1. FETCH TASKS (READ)
  // =========================================================
  const fetchTasks = useCallback(async () => {
    setLoading(true);
    try {
      // Query with Nested Joins: wh_requests -> wh_cells -> wh_nodes
      // We use explicit constraint names because wh_cells uses COMPOSITE Foreign Keys (graph_id, node_id)
      const { data, error } = await supabase
        .from('wh_requests')
        .select(`
          id,
          pickup_cell_id,
          delivery_cell_id,
          status,
          priority,
          created_at, 
          pickup:wh_cells!pickup_cell_id (
            node:wh_nodes!wh_cells_node_same_graph_fk (name)
          ),
          delivery:wh_cells!delivery_cell_id (
            node:wh_nodes!wh_cells_node_same_graph_fk (name)
          )
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;

      // Transform Raw DB Data -> Clean UI Data
      const formattedTasks: Task[] = (data as unknown as RawTaskDB[]).map((t) => ({
        id: t.id,
        pickup_cell_id: t.pickup_cell_id,
        delivery_cell_id: t.delivery_cell_id,
        pickup_name: t.pickup?.node?.name || 'Unknown Node',
        delivery_name: t.delivery?.node?.name || 'Unknown Node',
        status: t.status,
        priority: t.priority,
        queued_at: t.created_at || t.queued_at || new Date().toISOString(),
      }));

      setTasks(formattedTasks);
    } catch (err: unknown) {
      console.error('Error fetching tasks:', err);
      // Alert the user so they are not left in the dark
      const msg = err instanceof Error ? err.message : JSON.stringify(err);
      alert(`Error loading task list: ${msg}`);
    } finally {
      setLoading(false);
    }
  }, []);

  // =========================================================
  // 2. FETCH LOCATIONS (READ)
  // =========================================================
  const fetchLocations = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from('wh_cells')
        .select(`
          id,
          level:wh_levels!wh_cells_level_same_graph_fk (level),
          node:wh_nodes!wh_cells_node_same_graph_fk (name)
        `);

      if (error) throw error;

      // Transform into a simple list for Dropdowns
      // Explicitly checking for nulls to avoid UI crashes
      const validLocs: AvailableLocation[] = (data as any[]).map((d) => ({
        cell_id: d.id,
        node_name: d.node?.name || `Cell #${d.id}`,
        level: d.level?.level || 1,
      }));

      setLocations(validLocs);
      console.log("Locations fetched:", validLocs);

      if (validLocs.length === 0) {
        console.warn("Warning: No available cells found in database (wh_cells table is empty or joins failed).");
      }

    } catch (err: unknown) {
      console.error('Error fetching locations:', err);
      const msg = err instanceof Error ? err.message : JSON.stringify(err);
      alert(`Failed to load locations: ${msg}`);
    }
  }, []);

  // =========================================================
  // 3. ADD TASK (CREATE)
  // =========================================================
  const addTask = async (pickupCellId: number, deliveryCellId: number) => {
    // Note: 'created_at' is auto-generated by Postgres (DEFAULT now())
    const { error } = await supabase.from('wh_requests').insert({
      pickup_cell_id: pickupCellId,
      delivery_cell_id: deliveryCellId,
      status: 'queuing',
      priority: 0, // Default priority (0-100 range per schema)
    });

    if (error) {
      console.error('Insert Failed:', error);
      alert(`Failed to add task: ${error.message}`);
      return false;
    }

    await fetchTasks(); // Refresh list immediately
    return true;
  };

  // =========================================================
  // 4. DELETE TASK (DELETE)
  // =========================================================
  const deleteTask = async (id: number) => {
    // 1. Delete associated tasks first (Constraint Fix)
    const { error: taskError } = await supabase.from('wh_tasks').delete().eq('request_id', id);
    if (taskError) {
      console.error("Task Cleanup Error:", taskError);
      // Proceeding anyway might fail, but let's try or alert? 
      // If we can't delete tasks, we certainly can't delete the request.
      alert(`Failed to clean up associated tasks: ${taskError.message}`);
      return;
    }

    // 2. Delete the request
    const { error } = await supabase.from('wh_requests').delete().eq('id', id);

    if (error) {
      alert(`Failed to delete: ${error.message}`);
    } else {
      await fetchTasks();
    }
  };

  // Load initial data on mount
  useEffect(() => {
    fetchTasks();
    fetchLocations();
  }, [fetchTasks, fetchLocations]);

  return { tasks, locations, addTask, deleteTask, loading, refresh: fetchTasks };
};